// Functions.h
//
// ICS 65 Fall 2012
// Code Example
//
// This header file declares and defines a couple of template functions.
// Template functions are not one function; they're an infinite set of
// possible functions, which can be instantiated (i.e., generated by the
// compiler automatically) in different ways in different places in your
// program.  Simply by calling a template function, the compiler can
// detect that you're calling a version that's different than any it's
// compiled before, then generate the code on the fly automatically.
// Only the functions you actually call, and only the *versions* you
// actually call, ever get generated.

#ifndef FUNCTIONS_H
#define FUNCTIONS_H

#include <iostream>


// myswap() is a template function that takes two parameters of some
// type by reference and swaps their values.  It doesn't matter what
// the values of the parameters are, *except* that it matters that
// the two types are the same; we wouldn't expect to be able to swap
// a double with a string, for example.  (I named this function
// "myswap" instead of "swap" to avoid confusion with a standard
// library function, std::swap, that does exactly this.)
//
// So our template function specifies an infinite set of possible
// myswap functions that differ on the basis of the type of parameters
// we intend to pass them.  So our template takes one "template
// parameter" which is a type; this is denoted by the angle brackets
// and the word "typename" (which is a way to say "T is a type").
// The compiler will attempt to generate a myswap function for any
// type of parameter we try to pass to it; any time the compiler sees
// a call to myswap, it will attempt to deduce a T based on context
// (or, if we prefer, we can tell the compiler what T is), and if
// that's a new version (different than any version it's seen before),
// the template will be instantiated and turned into a new function
// where all the T's are replaced by the specific type.  So, for
// example, if we call this function and pass it two ints, the
// compiler will generate a function "myswap<int>", which takes
// two ints by reference and swaps their values.

template <typename T>
void myswap(T& t1, T& t2)
{
	T temp = t1;
	t1 = t2;
	t2 = temp;
}

// Now, you might be wondering why we're defining the function's body
// in the header file, rather than in a Functions.cpp source file
// instead.  The reason is that a template function definition
// doesn't actually cause any functions to be defined at all.  The
// compiler looks through it and does some rudimentary syntax and
// semantic checking -- basically verifying whether it's possible
// that the function will work for some type T -- then waits until you
// actually try to call it before creating any actual functions out of
// it.  The reason why it waits is simple: the template defines an
// infinite set of possible functions, but the compiler can't possibly
// compile *all* of the possibilities, so it just waits until it knows
// that it needs one.
//
// At the point where you call the function, the compiler will generate
// it for you.  That means the code for the function needs to be
// available in any source file in which a call is made; for that reason,
// we place the code into this header file, so that it's included into
// whatever source file intends to call it.
//
// Another interesting question is what types T is allowed to be.  In
// general, the answer is "anything" and, in fact, there's no syntax
// for explicitly limiting T (e.g., to a particular set of classes, or
// only to classes that inherit from a particular base).  Instead, T
// is limited implicitly by the things you do to T's inside of the
// function.
//
// So what are the constraints on T for this myswap() function?  The
// answer lies in looking at what we're doing to T's:
//
// * Taking them as parameter by reference.  Any kind of object can
//   be passed this way, so there is no limitation there.
// * Copy constructing a T (which is what we're doing on the first
//   line when we say "T temp = t1;")
// * Assigning a T (which is what we're doing on the other two lines)
//
// So, in short, T's must be "copyable" (i.e., they must have copy
// constructors and assignment operators).  Most types are copyable,
// so most types can be swapped.



// One more template function that will be handy in our main.cpp: a
// function that takes two arguments and prints them to an output
// stream, separated by a space.  There's no reason why the two
// arguments need to have the same type, so we'll write the template
// in a way that allows them to be different, by specifying two
// template parameters, one for each type.

template <typename T1, typename T2>
void printTwo(std::ostream& out, const T1& t1, const T2& t2)
{
	out << t1 << " " << t2;
}

// This function also imposes implicit limitations on its type parameters.
// In this case, we have two type parameters, T1 and T2, and each one is
// required to have an overloaded << operator that can write them to a
// std::ostream.  Many of the built-in types have this operator, but none
// of your own classes do (unless you overload the operator yourself).



#endif // FUNCTIONS_H
